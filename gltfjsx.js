const fs = require('fs')
require('jsdom-global')()
const THREE = (global.THREE = require('three'))
require('./bin/GLTFLoader')
const DracoLoader = require('./bin/dracoloader')
THREE.DRACOLoader.getDecoderModule = () => {}
const prettier = require('prettier')

const options = {}

function toArrayBuffer(buf) {
  var ab = new ArrayBuffer(buf.length)
  var view = new Uint8Array(ab)
  for (var i = 0; i < buf.length; ++i) view[i] = buf[i]
  return ab
}

const gltfLoader = new THREE.GLTFLoader()
gltfLoader.setDRACOLoader(new DracoLoader())

function rNbr(number) {
  return parseFloat(number.toFixed(options.precision))
}

function rDeg(number) {
  const eps = 0.001
  const abs = Math.abs(Math.round(parseFloat(number) * 100000))
  for (let i = 1; i <= 10; i++) {
    if (abs === Math.round(parseFloat(Math.PI / i) * 100000))
      return `${number < 0 ? '-' : ''}Math.PI${i > 1 ? ' / ' + i : ''}`
  }
  for (let i = 1; i <= 10; i++) {
    if (abs === Math.round(parseFloat(Math.PI * i) * 100000))
      return `${number < 0 ? '-' : ''}Math.PI${i > 1 ? ' * ' + i : ''}`
  }
  return rNbr(number)
}

function print(objects, obj, level = 0, parent) {
  let result = ''
  let space = new Array(level).fill(' ').join('')
  let children = ''
  let type = obj.type.charAt(0).toLowerCase() + obj.type.slice(1)

  // Turn object3d's to groups, it's faster
  if (type === 'object3D') type = 'group'

  // Bail out on lights and cameras
  if (obj instanceof THREE.Light || obj instanceof THREE.Camera)
    return `${space}<primitive object={nodes['${obj.name}']} />${!parent ? '' : '\n'}`

  // Collect children
  if (obj.children) obj.children.forEach(child => (children += print(objects, child, level + 2, obj)))

  // Form the object in JSX syntax
  result = `${space}<${type} `

  const oldResult = result

  // Write out materials
  if (obj.material) result += `material={materials['${obj.material.name}']} `
  if (obj.geometry) result += `geometry={nodes['${obj.name}'].geometry} `
  if (obj.name.length && !options.compress) result += `name="${obj.name}" `
  if (obj.visible === false) result += `visible={false} `
  if (obj.morphTargetDictionary) result += `morphTargetDictionary={nodes['${obj.name}'].morphTargetDictionary} `
  if (obj.morphTargetInfluences) result += `morphTargetInfluences={nodes['${obj.name}'].morphTargetInfluences} `
  if (obj.position instanceof THREE.Vector3 && obj.position.length())
    result += `position={[${rNbr(obj.position.x)}, ${rNbr(obj.position.y)}, ${rNbr(obj.position.z)},]} `
  if (obj.rotation instanceof THREE.Euler && obj.rotation.toVector3().length())
    result += `rotation={[${rDeg(obj.rotation.x)}, ${rDeg(obj.rotation.y)}, ${rDeg(obj.rotation.z)},]} `
  if (obj.scale instanceof THREE.Vector3 && obj.scale.x !== 1 && obj.scale.y !== 1 && obj.scale.z !== 1)
    result += `scale={[${rNbr(obj.scale.x)}, ${rNbr(obj.scale.y)}, ${rNbr(obj.scale.z)},]} `

  // Remove empty groups
  if (options.compress && (type === 'group' || type === 'scene') && (result === oldResult || obj.children.length === 0))
    return children

  // Close tag
  result += `${children.length ? '>' : '/>'}\n`

  // Add children and return
  if (children.length) result += children + `${space}</${type}>${!parent ? '' : '\n'}`
  return result
}

function printClips(gltf) {
  return (
    '{\n' +
    gltf.animations
      .map((clip, i) => `      "${clip.name}": mixer.clipAction(animations[${i}], group.current)`)
      .join(',\n') +
    '    }'
  )
}

function printAnimations(gltf) {
  return gltf.animations && gltf.animations.length
    ? `\n\n  const actions = useRef()
  const [mixer] = useState(() => new THREE.AnimationMixer())
  useFrame((state, delta) => mixer.update(delta))
  useEffect(() => {
    actions.current = ${printClips(gltf)}
    return () => animations.forEach(clip => mixer.uncacheClip(clip))
  }, [])`
    : ''
}

module.exports = function(file, output, exportOptions) {
  Object.keys(exportOptions).forEach(key => (options[key] = exportOptions[key]))

  const nameExt = file.match(/[-_\w]+[.][\w]+$/i)[0]
  const name = nameExt
    .split('.')
    .slice(0, -1)
    .join('.')

  const stream = fs.createWriteStream(output || name.charAt(0).toUpperCase() + name.slice(1) + '.js')
  stream.once('open', fd => {
    if (!fs.existsSync(file)) {
      console.error(`\nERROR: The input file: "${file}" does not exist at this path.\n`)
    } else {
      const data = fs.readFileSync(file)
      const arrayBuffer = toArrayBuffer(data)
      gltfLoader.parse(
        arrayBuffer,
        '',
        gltf => {
          const objects = []
          gltf.scene.traverse(child => objects.push(child))

          const result = `// Auto-generated by https://github.com/react-spring/gltfjsx

import * as THREE from 'three'
import React, { useEffect, useRef${options.animation ? ', useState' : ''} } from 'react'
import { useLoader, useFrame } from 'react-three-fiber'
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'${
            options.draco ? `\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader'` : ``
          }
  
export default function Model(props) {
  const group = useRef()
  const { nodes, materials, animations } = useLoader(GLTFLoader, '/${nameExt}'${
            options.draco
              ? `, loader => {
    const dracoLoader = new DRACOLoader()
    dracoLoader.setDecoderPath('/draco-gltf/')
    loader.setDRACOLoader(dracoLoader)
  }`
              : ``
          })${options.animation ? printAnimations(gltf) : ``}

  return (
    <group ref={group} {...props} dispose={null}>
${print(objects, gltf.scene, 6)}
    </group>
  )
}`

          stream.write(
            prettier.format(result, {
              semi: false,
              printWidth: 120,
              singleQuote: true,
              jsxBracketSameLine: true,
              parser: 'babel',
            })
          )
          stream.end()
        },
        event => {
          console.log(event)
          console.log('loader failed')
        }
      )
    }
  })
}
